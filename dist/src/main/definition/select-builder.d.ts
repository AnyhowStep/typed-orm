import * as d from "../declaration";
import * as sd from "schema-decorator";
import { Database } from "./Database";
import { ConnectedDatabase } from "./ConnectedDatabase";
export declare const ArbitraryRowCount = 999999999;
export interface LimitData {
    readonly rowCount: number;
    readonly offset: number;
}
export interface ExtraSelectBuilderData {
    readonly db: Database | ConnectedDatabase;
    readonly narrowExpr?: d.IExpr<any, boolean>;
    readonly whereExpr?: d.IExpr<any, boolean>;
    readonly havingExpr?: d.IExpr<any, boolean>;
    readonly union?: d.ISelectBuilder<any>[];
    readonly distinct: boolean;
    readonly sqlCalcFoundRows: boolean;
    readonly groupByTuple?: d.AnyGroupByTupleElement[];
    readonly orderByTuple?: d.AnyOrderByTupleElement[];
    readonly limit?: LimitData;
    readonly unionOrderByTuple?: d.AnyOrderByTupleElement[];
    readonly unionLimit?: LimitData;
}
export declare class SelectBuilder<DataT extends d.AnySelectBuilderData> implements d.ISelectBuilder<DataT> {
    readonly data: DataT;
    readonly extraData: ExtraSelectBuilderData;
    constructor(data: DataT, extraData: ExtraSelectBuilderData);
    assertAfterSelect(): void;
    assertBeforeUnion(): void;
    assertNonDuplicateAlias(alias: string): void;
    assertEqualLength(a: any[], b: any[]): void;
    join<ToTableT extends d.AnyAliasedTable, FromTupleT extends d.JoinFromTupleCallback<DataT["columnReferences"]>>(toTable: ToTableT, from: FromTupleT, to: d.JoinToTupleCallback<ToTableT, d.JoinFromTupleOfCallback<FromTupleT>>): any;
    rightJoin<ToTableT extends d.AnyAliasedTable, FromTupleT extends d.JoinFromTupleCallback<DataT["columnReferences"]>>(toTable: ToTableT, from: FromTupleT, to: d.JoinToTupleCallback<ToTableT, d.JoinFromTupleOfCallback<FromTupleT>>): any;
    leftJoin<ToTableT extends d.AnyAliasedTable, FromTupleT extends d.JoinFromTupleCallback<DataT["columnReferences"]>>(toTable: ToTableT, from: FromTupleT, to: d.JoinToTupleCallback<ToTableT, d.JoinFromTupleOfCallback<FromTupleT>>): any;
    joinUsing<ToTableT extends d.AnyAliasedTable, FromTupleT extends d.JoinFromTupleCallback<DataT["columnReferences"]>>(toTable: ToTableT, from: FromTupleT): any;
    rightJoinUsing<ToTableT extends d.AnyAliasedTable, FromTupleT extends d.JoinFromTupleCallback<DataT["columnReferences"]>>(toTable: ToTableT, from: FromTupleT): any;
    leftJoinUsing<ToTableT extends d.AnyAliasedTable, FromTupleT extends d.JoinFromTupleCallback<DataT["columnReferences"]>>(toTable: ToTableT, from: FromTupleT): any;
    private appendNarrowData;
    private appendWhereExpr;
    private appendNarrowExpr;
    whereIsNotNull<TypeNarrowCallbackT extends d.TypeNarrowCallback<DataT["columnReferences"]>>(typeNarrowCallback: TypeNarrowCallbackT): any;
    whereIsNull<TypeNarrowCallbackT extends d.TypeNarrowCallback<DataT["columnReferences"]>>(typeNarrowCallback: TypeNarrowCallbackT): any;
    whereIsEqual<ConstT extends boolean | number | string, TypeNarrowCallbackT extends d.TypeNarrowCallback<DataT["columnReferences"]>>(value: ConstT, typeNarrowCallback: TypeNarrowCallbackT): any;
    where<WhereCallbackT extends d.WhereCallback<d.ISelectBuilder<DataT>>>(whereCallback: WhereCallbackT): SelectBuilder<DataT>;
    andWhere<WhereCallbackT extends d.WhereCallback<d.ISelectBuilder<DataT>>>(whereCallback: WhereCallbackT): SelectBuilder<DataT>;
    private appendSelectTuple;
    select<SelectCallbackT extends d.SelectCallback<d.ISelectBuilder<DataT>>>(selectCallback: SelectCallbackT): any;
    selectAll(): any;
    distinct(distinct?: boolean): SelectBuilder<DataT>;
    sqlCalcFoundRows(sqlCalcFoundRows?: boolean): SelectBuilder<DataT>;
    groupBy<GroupByCallbackT extends d.GroupByCallback<d.ISelectBuilder<DataT>>>(groupByCallback: GroupByCallbackT): SelectBuilder<DataT>;
    appendGroupBy<GroupByCallbackT extends d.GroupByCallback<d.ISelectBuilder<DataT>>>(groupByCallback: GroupByCallbackT): SelectBuilder<DataT>;
    unsetGroupBy(): SelectBuilder<DataT>;
    having<HavingCallbackT extends d.HavingCallback<d.ISelectBuilder<DataT>>>(havingCallback: HavingCallbackT): SelectBuilder<DataT>;
    andHaving<HavingCallbackT extends d.HavingCallback<d.ISelectBuilder<DataT>>>(havingCallback: HavingCallbackT): SelectBuilder<DataT>;
    orderBy<OrderByCallbackT extends d.OrderByCallback<d.ISelectBuilder<DataT>>>(orderByCallback: OrderByCallbackT): SelectBuilder<DataT>;
    appendOrderBy<OrderByCallbackT extends d.OrderByCallback<d.ISelectBuilder<DataT>>>(orderByCallback: OrderByCallbackT): SelectBuilder<DataT>;
    unsetOrderBy(): SelectBuilder<DataT>;
    limit(rowCount: number): SelectBuilder<DataT>;
    offset(offset: number): SelectBuilder<DataT>;
    unsetLimit(): SelectBuilder<DataT>;
    widen<TypeWidenCallbackT extends d.TypeWidenCallback<DataT["selectReferences"]>, WidenT>(typeWidenCallback: TypeWidenCallbackT, assertWidened: sd.AssertFunc<WidenT>): any;
    union<SelectBuilderT extends d.ISelectBuilder<{
        hasSelect: true;
        hasUnion: any;
        columnReferences: any;
        joins: any;
        selectReferences: any;
        selectTuple: any;
        aggregateCallback: any;
    }>>(other: SelectBuilderT): any;
    unionOrderBy<OrderByCallbackT extends d.OrderByCallback<d.ISelectBuilder<DataT>>>(orderByCallback: OrderByCallbackT): SelectBuilder<DataT>;
    appendUnionOrderBy<OrderByCallbackT extends d.OrderByCallback<d.ISelectBuilder<DataT>>>(orderByCallback: OrderByCallbackT): SelectBuilder<DataT>;
    unsetUnionOrderBy(): SelectBuilder<DataT>;
    unionLimit(rowCount: number): SelectBuilder<DataT>;
    unionOffset(offset: number): SelectBuilder<DataT>;
    unsetUnionLimit(): SelectBuilder<DataT>;
    as<AliasT extends string>(alias: AliasT): any;
    asExpr<AliasT extends string>(alias: AliasT): any;
    readonly from: d.CreateSubSelectBuilderDelegate<DataT["columnReferences"]>;
    aggregate<AggregateCallbackT extends d.AggregateCallback<DataT>>(aggregateCallback: AggregateCallbackT): any;
    querifyColumnReferences(sb: d.IStringBuilder): void;
    querifyWhere(sb: d.IStringBuilder): void;
    querify(sb: d.IStringBuilder): string;
    private schema;
    private getSchema;
    private readonly processRow;
    private readonly aggregateRow;
    private getQuery;
    fetchAll(): any;
    fetchOne(): any;
    fetchZeroOrOne(): any;
    fetchValue(): any;
    fetchValueOrUndefined(): any;
    fetchValueArray(): any;
    count(): Promise<number>;
    exists(): Promise<boolean>;
    paginate(rawPaginationArgs?: d.RawPaginationArgs): any;
}
export declare function newCreateSelectBuilderDelegate(db: Database | ConnectedDatabase): d.CreateSelectBuilderDelegate;
