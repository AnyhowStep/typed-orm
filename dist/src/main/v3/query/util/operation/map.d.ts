import { Query } from "../../query";
import { AfterSelectClause } from "../predicate";
import { MapDelegate } from "../../../map-delegate";
import { SelectItem } from "../../../select-item";
import { SelectItemArrayUtil } from "../../../select-item-array";
import { IJoin } from "../../../join";
import { UnmappedFetchRef } from "../../../unmapped-fetch-ref";
import { UnmappedFetchMap } from "../../../unmapped-fetch-map";
export declare type UseUnmappedFetchRef<SelectsT extends SelectItem[], JoinsT extends IJoin[]> = (true extends (SelectItemArrayUtil.HasDuplicateColumnName<SelectsT> | JoinsT[number]["nullable"]) ? true : false);
export declare type UnmappedTypeNoJoins<SelectsT extends SelectItem[]> = (UseUnmappedFetchRef<SelectsT, []> extends true ? UnmappedFetchRef<SelectsT, []> : UnmappedFetchMap<SelectsT>);
export declare type UnmappedType<QueryT extends AfterSelectClause> = (QueryT["_joins"] extends IJoin[] ? (UseUnmappedFetchRef<QueryT["_selects"], QueryT["_joins"]> extends true ? UnmappedFetchRef<QueryT["_selects"], QueryT["_joins"]> : UnmappedFetchMap<QueryT["_selects"]>) : UnmappedTypeNoJoins<QueryT["_selects"]>);
export declare type MappedType<QueryT extends AfterSelectClause> = (QueryT["_mapDelegate"] extends MapDelegate ? (ReturnType<QueryT["_mapDelegate"]> extends Promise<infer R> ? R : ReturnType<QueryT["_mapDelegate"]>) : UnmappedType<QueryT>);
export declare type Map<QueryT extends AfterSelectClause, DelegateT extends MapDelegate<MappedType<QueryT>, UnmappedType<QueryT>, any>> = (Query<{
    readonly _distinct: QueryT["_distinct"];
    readonly _sqlCalcFoundRows: QueryT["_sqlCalcFoundRows"];
    readonly _joins: QueryT["_joins"];
    readonly _parentJoins: QueryT["_parentJoins"];
    readonly _selects: QueryT["_selects"];
    readonly _where: QueryT["_where"];
    readonly _grouped: QueryT["_grouped"];
    readonly _having: QueryT["_having"];
    readonly _orders: QueryT["_orders"];
    readonly _limit: QueryT["_limit"];
    readonly _unions: QueryT["_unions"];
    readonly _unionOrders: QueryT["_unionOrders"];
    readonly _unionLimit: QueryT["_unionLimit"];
    readonly _mapDelegate: MapDelegate<UnmappedType<QueryT>, UnmappedType<QueryT>, ReturnType<DelegateT> extends Promise<any> ? ReturnType<DelegateT> : Promise<ReturnType<DelegateT>>>;
}>);
export declare function map<QueryT extends AfterSelectClause, DelegateT extends MapDelegate<MappedType<QueryT>, UnmappedType<QueryT>, any>>(query: QueryT, delegate: DelegateT): Map<QueryT, DelegateT>;
